plugins{
	id 'java'
	id 'jacoco-report-aggregation'
	id 'eclipse'
	id 'application'
	id 'base'
}

import org.apache.tools.ant.filters.ReplaceTokens


mainClassName = 'org.opt4j.core.start.Opt4J'

/*
 * define global parameters here, e.g. versions numbers of tools which need to be consistent for all subprojects
 * they are all accesible via project.parametername e.g. project.opt4jJavaVersion to get the used java version for Opt4J
 */
ext{
	opt4jJavaVersion = "21"
	guiceVersion = "7.0.0"
	sat4jVersion = "2.3.6"
	junitVersion = "5.10.2"
	mockitoVersion = "5.10.0"
	jacocoVersion = "0.8.11"
}

jacoco{
	toolVersion = project.jacocoVersion
}


java {
	withJavadocJar()
	withSourcesJar()
	sourceCompatibility = project.opt4jJavaVersion
	targetCompatibility = project.opt4jJavaVersion
    toolchain {
    	languageVersion.set(JavaLanguageVersion.of(project.opt4jJavaVersion))
    }
}

/*
 * Gets the version name from the latest Git tag
 */
def getVersionName = {
	->
	def stdout = new ByteArrayOutputStream()
	exec {
		commandLine 'git', 'describe', '--tags', '--first-parent'
		standardOutput = stdout
		ignoreExitValue true
	}
	version=stdout.toString().trim()
	if (version.count('-') > 1 || version.isEmpty())
		version += '-SNAPSHOT'
	if (version.getAt(0) == 'v')
		version = version.substring(1)
	return version
}
version=getVersionName()



ext {
	dateISO = new Date().format("yyyy-MM-dd")
}

allprojects {
	group = 'org.opt4j'

	repositories {
		mavenCentral()
	}
}

def descriptions = [
	'opt4j-core' : 'The core module of Opt4J',
	'opt4j-benchmarks' : 'A set of benchmarks for Opt4J',
	'opt4j-operators' : 'A set of operators for Opt4J',
	'opt4j-optimizers' : 'A set of optimizers for Opt4J',
	'opt4j-satdecoding' : 'The SAT decoding module for Opt4J',
	'opt4j-tutorial' : 'The tutorial classes for Opt4J',
	'opt4j-viewer' : 'The viewer module for Opt4J'
]


    dependencies {
		testImplementation(platform('org.junit:junit-bom:5.10.2'))
		testImplementation('org.junit.jupiter:junit-jupiter')
		testRuntimeOnly('org.junit.platform:junit-platform-launcher')
		testImplementation('org.mockito:mockito-junit-jupiter:5.10.0')
    }

subprojects {
	apply plugin: 'java'
	apply plugin: 'signing'
	apply plugin: 'eclipse'
	apply plugin: 'jacoco'

	version = parent.version

	sourceSets {
		integrationTest {
			java {
				compileClasspath += main.output + main.compileClasspath + test.compileClasspath
				runtimeClasspath += main.output + main.compileClasspath + test.compileClasspath
				srcDir file('src/test-integration/java')
			}
			resources.srcDir file('src/test-integration/resources')
		}
	}
	task integrationTest(type: Test) {
		testClassesDirs = sourceSets.integrationTest.output.classesDirs
		classpath = sourceSets.integrationTest.runtimeClasspath
	}

	task sourcesJar(type: Jar, dependsOn:classes) {
		from sourceSets.main.allSource
		archiveClassifier.set('sources')
	}

	task javadocJar(type: Jar, dependsOn:javadoc) {
		from javadoc.destinationDir
		archiveClassifier.set('javadoc')
	}
	
	java {
		withJavadocJar()
		withSourcesJar()
		sourceCompatibility = project.opt4jJavaVersion
		targetCompatibility = project.opt4jJavaVersion
    	toolchain {
    		languageVersion.set(JavaLanguageVersion.of(project.opt4jJavaVersion))
    	}
    }
 	
 	test {
	    // Enable JUnit 5 (Gradle 4.6+).
	    useJUnitPlatform()

	    // Always run tests, even when nothing changed.
	    dependsOn 'cleanTest'

	    // Show test results.
	    testLogging {
	        events "passed", "skipped", "failed"
		}
	}
 	

	jacoco{
		toolVersion = project.jacocoVersion
	}

	jacocoTestReport {
		getAdditionalSourceDirs().setFrom(sourceSets.main.allSource.srcDirs)
		getSourceDirectories().setFrom(sourceSets.main.allSource.srcDirs)
		getClassDirectories().setFrom(sourceSets.main.output)
		reports {
			html.required = true
			csv.required = true
			xml.required = true
		}
	}
 //}
}


dependencies {
	implementation project(':opt4j-core')
	implementation project(':opt4j-satdecoding')
	implementation project(':opt4j-operators')
	implementation project(':opt4j-optimizers')
	implementation project(':opt4j-benchmarks')
	implementation project(':opt4j-viewer')
	implementation project(':opt4j-tutorial')
}

jar {
	manifest {
		attributes 'Main-Class': mainClassName
	}
}


artifacts {
	archives sourcesJar
    archives javadocJar
}

/* for now ignore all javadoc errors in case of Java 8 */
if (JavaVersion.current().isJava8Compatible()) {
	allprojects {
		tasks.withType(Javadoc) {
			options.addStringOption('Xdoclint:none', '-quiet')
		}
	}
}

task copyWebsite(type: Copy){
	from('src/main/website/') {
		include '**/*.html'
		filter(ReplaceTokens, tokens: [version : project.version, date : project.dateISO])
	}
	from('src/main/website/') {
		exclude '**/*.html'
	}
	into 'build/website/'
}

task copyJavadoc(type: Copy, dependsOn: 'alldocs'){
	from new File(project.buildDir, 'docs/javadoc')
	into 'build/website/javadoc/'+version
}

task copyTutorial(type: Copy, dependsOn: ":opt4j-tutorial:tutorial"){
	from new File(project(':opt4j-tutorial').buildDir,'tutorial')
	into 'build/website/documentation/'+version
}

task website(dependsOn: [copyWebsite, copyJavadoc, copyTutorial]) {
	description = 'build the website to deploy it when releasing'
	group = 'distribution'
}



task alldocs(type: Javadoc) {
	title = "Opt4J version $version Project API Documentation"
	destinationDir = new File(project.buildDir, 'docs/javadoc')
	options.memberLevel = org.gradle.external.javadoc.JavadocMemberLevel.PUBLIC
	options.links "https://docs.oracle.com/en/java/javase/${project.opt4jJavaVersion}/docs/api/","http://google.github.io/guice/api-docs/${guiceVersion}/javadoc/"
	options.linkSource = true
	subprojects.each {subproject ->
		source subproject.sourceSets.main.java
	}
	exclude 'ptolemy/**'
	subprojects.each { subproject ->
		if( classpath ) {
			classpath += subproject.sourceSets.main.output + subproject.sourceSets.main.compileClasspath
		} else {
			classpath = subproject.sourceSets.main.output + subproject.sourceSets.main.compileClasspath
		}
	}
}

import org.apache.tools.ant.filters.ReplaceTokens
applicationDistribution.from("src/distribution") {
    filter(ReplaceTokens, tokens: [version : project.version, date : project.dateISO])
}

task fatjar(dependsOn: subprojects.jar, type: Jar) {
	destinationDirectory = new File(project.buildDir, 'fatjar')
	from {
		configurations.runtime.collect {
			it.isDirectory() ? it : zipTree(it)
		}
	}
	manifest {
		attributes 'Main-Class': mainClassName
		attributes 'SplashScreen-Image': 'img/splash.png'
	}
}


applicationDefaultJvmArgs = [
	"-splash:opt4j-core/src/main/resources/img/splash.png"
]

task jacocoRootReport(type: org.gradle.testing.jacoco.tasks.JacocoReport) {
	dependsOn(subprojects.test)
	getAdditionalSourceDirs().setFrom(subprojects.sourceSets.main.allSource.srcDirs)
	getSourceDirectories().setFrom(subprojects.sourceSets.main.allSource.srcDirs)
	getClassDirectories().setFrom(subprojects.sourceSets.main.output)
	executionData.from = files(subprojects.jacocoTestReport.executionData)
	reports {
		xml.required = true
		xml.outputLocation = file("${buildDir}/reports/jacoco/rootReport.xml")
		html.required = true
		html.outputLocation = file("${buildDir}/reports/jacoco")
		csv.required = true
		csv.outputLocation = file("${buildDir}/reports/jacoco/rootReport.csv")
	}
	onlyIf = {
		true
	}
	afterEvaluate {
		getClassDirectories().setFrom(classDirectories.files.collect {
			fileTree(dir: it, exclude: [
				'ptolemy/**',
				'org/opt4j/tutorial/**',
				'org/opt4j/viewer/**',
				'org/opt4j/core/config/visualization/**'
			])
		})
	}
}
